<?php

// seederの例


/*
    |--------------------------------------------------------------------------
    |
    | ■ サービスコンテナとは
    |
    |--------------------------------------------------------------------------
    |
    | 「クラスをインスタンス化してくれるマシーン」
    | $classA = new ClassA();
    | ⬇︎ サービスコンテナを使うと・・・
    | $classA = app()->make(ClassA::class);
    | このapp()関数でサービスコンテナを取得し、そのサービスコンテナのmake()メソッドでインスタンス化しています。
    */




/*
    |--------------------------------------------------------------------------
    |
    | ■ シリアライズして任意の型を暗号化  参照先  https://qiita.com/saya1001kirinn/items/2495bf4889c3d97c3e10
    |
    |--------------------------------------------------------------------------
    |
    | 暗号化は、 .env で設定された APP_KEY=base64:XXXXXX をシークレットとして使用します。
    |
    |
    |
    |
    */
// use文を挿入する
// use Illuminate\Support\Facades\Crypt;



//
/*
Base64エンコードされた暗号化結果が出力される
*/
$encrypted = Crypt::encrypt(['foo' => 'bar']);
// 'login_password' => Crypt::encrypt('test'),


/*
/ 複合化された（暗号化した情報を元に戻した）結果が出力される
*/
$decrypted = Crypt::decrypt($encrypted);


/*
    |--------------------------------------------------------------------------
    |
    | flushEventListenersについて 参照先 https://qiita.com/pinekta/items/86ccec485c8e1d199487
    |
    |--------------------------------------------------------------------------
    |
    |
    |
    |
    |
    |
    */
// オブザーバーを無効にする
Model::flushEventListeners();
// オブザーバーを無効にしたあとに有効にするには
// Model::observe(ModelObserver::class)


/*
    |--------------------------------------------------------------------------
    |
    | オブザーバについて 参照先 https://ryuzan03.hatenablog.com/entry/2019/09/28/190000
    |
    |--------------------------------------------------------------------------
    |
    | オブザーバとは？
    | モデルを監視し、実行されるイベントに対応するメソッドを呼んでくれます。
    | イベントフックが多い場合に、イベントフックをまとめてオブザーバ(observer)に定義することができる。
    | ※コントローラの肥大化を防ぐことができます。
    |
    */

    /*
    |--------------------------------------------------------------------------
    |
    | シーダーでよく使う記法1 参照先 https://www.ritolab.com/entry/93
    |
    |--------------------------------------------------------------------------
    | 入力値を連想配列として取得する
    | all() toArray() input()
    |

    |
    */
/*

3つはどれも入力値を連想配列として取得することができます。
またその際、HTTP動詞は考慮しません。

$request->all();
⬇︎ toArrayは内部でall()を呼んでそのまま返してる
$request->toArray();
$request->input();
*/

    /*
    |--------------------------------------------------------------------------
    |
    | シーダーでよく使う記法2 参照先 参照先 https://qiita.com/yukachin0414/items/b561afcad793de9ca2f4
    |
    |--------------------------------------------------------------------------
    | ■ Collectionのtakeメソッド
    | 指定した件数だけデータ取得する
    | take(3)
    | 使い方の見本は以下に記します
    */
/*
Collectionの中から特定の件数だけを取得することができます。
$collection = collect(['赤', '青', '黄', '緑', '白',]);
$chunk = $collection->take(3);

後ろから指定した数の値を取得することができます。
$chunk = $collection->take(-2);
*/
    /*
    |--------------------------------------------------------------------------
    |
    | シーダーでよく使う記法3  参照先 https://www.ritolab.com/entry/93
    |
    |--------------------------------------------------------------------------
    | ■ TRUNCATE
    |
    | 使い方の見本は以下に記します
    */
/*
delete()メソッドは単純にレコードを削除するだけなので、もし全レコードを削除しても、自動増分IDはリセットされません。
もしテーブル内を全て削除し、オートインクリメントもリセットしたい場合は、truncate()メソッドを使います。

*/
    /*
    |--------------------------------------------------------------------------
    |
    | シーダーでよく使う記法4 参照先 https://www.ritolab.com/entry/93
    |
    |--------------------------------------------------------------------------
    | ■  latest() メソッド
    | latest() メソッドを使うと、降順で取得します。
    |
    | 使い方の見本は以下に記します
    |
    */
/*


*/

    /*
    |--------------------------------------------------------------------------
    |
    | Laravel クエリビルダ記法まとめ 参照先 https://www.ritolab.com/entry/93
    |
    |--------------------------------------------------------------------------
    |
    | ※ 主要な内容だけ説明としてメモしておきます
    |
    | クエリビルダを使用する為の基本書式
    | 基本的な書式を以下に示します。
    |
    */


/*

use Illuminate\Support\Facades\DB; // DB ファサードを use する


public function getDate()
{
    // テーブルを指定
    $users = DB::table('users');
}

DB ファサードを use します。
DB ファサードの table メソッドを使い、引数に取得したいテーブル名を渡します。
今回は例として users テーブルから情報を取得する為のクエリビルダを記述していきますが、users テーブルのクエリビルダインスタンスを格納した変数 $users に対してクエリを記述し、結果を取得していきます。

irst()
結果データの最初の1件のみを取得します。結果が何件であっても、1件のみを取得します。

$data = $users->first();
結果データはStdClassオブジェクトで取得されます。取り出すにはオブジェクトのプロパティにアクセスします。

echo $data->name;
value()
value()メソッドで指定した1つのカラムのみを取得します。

$data = $users->value('email');
ただしこのメソッドは条件に限らず1件のみを取得するので、where句などと併用して狙った1件を取得する際などに使います。

echo $data; // test01@test.com
pluck()
pluck()メソッドで指定カラム1つだけをコレクションで取得できます。

$data = $users->pluck('email');

toSql()
toSql() メソッドで、発行しようとしているSQL文を確認できます。

$data = $users->toSql();


分割処理
レコードを取得し処理を行おうとした際に、対象レコードが数万件レベルであった場合は一度に取得する事は難しいかもしれません。

そんな時は chunk() メソッドを使えば、取得条件に対して分割処理を行う事ができます。

$users->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
        //
    }
});
上記の例では、usersテーブルに対し100件ずつレコードを取得し、クロージャの中でそれらを処理する事ができます。

例えば、users の全体件数は 10,000 件だけど、100 件ずつ取り出して処理を行ったり。リソースを節約しながら処理を行っていくことができます。

１点気を付ける事は、chunk() メソッドを使用する際は必ず orderBy() でデータの並び順を指定する必要があります。


count()
count()メソッドで、レコードの件数を取得できます。



SQL文を直接記述する
クエリビルダの中で、直接SQL文を記述する事もできます。

DB::rawメソッドを使ってSQL文を記述していきます。

$data = $users->select(DB::raw('COUNT(*) AS user_count'))->get();
rawメソッド
DB::rawは最も基本的なSQL文挿入メソッドです。更に各セクション毎に用意されているrawメソッドを使う事によって、記述を短縮できます。

selectRaw
selectRawメソッドは select(DB::raw(...)) 式を置き換えます。

$data = $users->selectRaw('COUNT(*) AS user_count')->get();


日時比較
日時の比較を行う際にも、Laravelのクエリビルダには専用のメソッドが用意されています。

whereDate / orWhereDate
日付比較にはwhereDate()メソッドを使います。

$data = $users->whereDate('updated_at', '2018-03-21')->get();

orderBy
orderBy()メソッドを使うと、指定したカラムで結果データをソートします。

$data = $users->orderBy('id', 'desc')->get();
第一引数にカラム名、第二引数に昇順(asc)、もしくは降順(desc)のどちらかを指定します。


グループ化（GROUP BY）と絞り込み（HAVING）
集計を行う際に GROUP BY や HAVING を使いたい場面もよくあると思いますが、その場合はgroupBy()メソッド、そしてhaving()メソッドを使います。

$data = $users
    ->selectRaw('role, sum(role) AS role_cnt')
    ->groupBy('role')
    ->having('role', '>', 5)
    ->get();

// => SELECT role, sum(role) AS role_cnt FROM `users` GROUP BY `role` HAVING `role` > 5
もちろん、groupBy()メソッドに複数のカラムを指定する事も可能です。

$data = $users
    ->selectRaw('`role`, sum(role) AS role_cnt')
    ->groupBy('role', 'gender')
    ->having('role', '>', 5)
    ->get();

// => SELECT `role`, sum(role) AS role_cnt FROM `users` GROUP BY `role`, `gender` HAVING `role` > 5

LIMIT
取得レコード数を制限するには、limit()メソッドを使います。

$data = $users->limit(3)->get();
OFFSET
結果レコードの取得開始位置（何件目から取得するか）を指定するには、offset()メソッドを使います。

$data = $users
    ->offset(2)
    ->limit(3)
    ->get();
OFFSETは得てしてLIMIT節と組み合わせて使う事が多いですが、上記の例の場合では「2件目から3件取得する」という意味になります。

判定式によって検索条件を変更する
「リクエストであのパラメータが来た場合は、検索条件にこれを追加する」
のような流れは良くあるパターンです。

Laravelのクエリビルダには、そのパターンでのSQL文組み立てにも対応しています。

when()メソッドを使い、第一引数に判定式の結果（trueもしくはfale）、第二引数にクロージャを指定し、trueであった場合の処理をクロージャに定義します。

$user_id = 8;

$data = $users
    ->when($user_id, function ($query) use ($user_id) {
        return $query->where('id', $user_id);
    })
    ->get();
上記例の場合、
「$user_idがtrue（すなわち、値が入っている）の場合は、idカラムをその値で指定する」
という条件が追加されます。

INSERT
テーブルへデータを登録（レコードを挿入）するには、insert()メソッドを使います。

$data = $users
    ->insert(
        [
            'name' => 'test11',
            'email' => 'test11@test.com',
            'password' => '123456',
            'role' => 5
        ]
    );
1つの配列に1件のデータを格納（プロパティ名をカラム名にする）しています。

*/














